#!/usr/bin/env ruby
$stderr.puts "#{Time.now} Loading service script"
File.open ::File.expand_path('../../tmp/pids/service.pid', 'w') do |f|
  f.puts Process.pid.to_s
end
at_exit do
  FileUtils.rm '../../tmp/pids/service.pid'
end
require ::File.expand_path('../../config/environment',  __FILE__)

ROUND_LENGTH = 5 * 60

def l(str)
  Scorebot.log str
end

def now_sec
  Time.now.to_i
end

def chillax(ending)
  l "Waiting #{ending - now_sec} seconds"
  if (ending - now_sec) > 5
    midpoint = now_sec + ((ending - now_sec) / 2)
  else
    # never reached
    midpoint = ending + 1
  end

  while now_sec < ending
    if (now_sec > midpoint) && (ending - now_sec > 5)
      midpoint = now_sec + ((ending - now_sec) / 2)
      l "Waiting #{ending - now_sec} more seconds"
    end
    sleep 0.1
  end
end

# availability check lengths, in seconds
# defaults to four minutes so we tend to schedule
# earlier
@availability_history = [ 4 * 60 ]

def average_check
  @availability_history.sum.to_f / @availability_history.length
end

if Round.current.nil?
  l "No current round. Press enter to start game."
  gets

  new_round = Round.create
  l "Commencing..."
  new_round.commence!
  l "It's on!"
end

loop do
  loop_start = Time.now

  l "Started service check"

  current_round = Round.current

  unless Timer.round.ended?

    round_timer = Timer.round.reload
    ending_sec = round_timer.ending.to_i

    unless current_round.availability_checks_done?
      l "Scheduling availability checks"
      envelope = ending_sec - now_sec
      longest_wait = envelope - average_check

      l "#{envelope} remaining, #{longest_wait} is the longest i should wait"

      if longest_wait < 0
        l "I THINK I'VE RUN OUT OF TIME FOR AVAILABILITY CHECKS :("
        l "GONNA DO THEM NOW AND JUST DWI IF THE ROUND IS DELAYED"
        longest_wait = 0
      end

      if longest_wait > 1
        wait = rand(longest_wait)
        l "Waiting #{wait} for availability check"
        alarm = now_sec + wait

        chillax alarm
      end
      
      l "Running checks"
      check_start = now_sec
      current_round.check_availability
      check_end = now_sec

      @availability_history.push check_end - check_start

      l "Checks ran in #{@availability_history.last} seconds"
    end

    l "Waiting for round end"
    chillax ending_sec

  end

  current_round.transaction do
    l "Ending round"
    current_round.ended_at ||= Time.now
    current_round.save

    if Timer.today.ended?
      @ending = true
    else
      new_round = Round.create
      l "Started round #{new_round.id}"
      new_round.commence!
    end
 
    current_round.finalize!
  end

  break if @ending
end
